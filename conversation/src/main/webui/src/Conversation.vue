<template>
  <div class="w-screen text-center mt-4 mb-8">
    <h1 class="mb-4 text-4xl font-extrabold tracking-tight leading-none text-gray-900 md:text-5xl lg:text-6xl dark:text-white">
      Let's chat
    </h1>
  </div>
  <div class="w-screen grid grid-cols-4 justify-items-center gap-4 pl-8 pr-8">
    <Persona :persona="persona" @reset="fetchPersona" />
    <div class="w-full mb-6 text-center col-span-3">
      <div id="alert-additional-content-2" class="p-4 mb-4 text-yellow-800 border border-yellow-300 rounded-lg bg-yellow-50 dark:bg-gray-800 dark:text-yellow-300 dark:border-yellow-800" role="alert">
        <div class="mt-2 mb-2 text-sm text-left ">
          <strong>Warning:</strong> The following text is generated by an AI and involves role-playing for real characters. While the portrayal may resemble real individuals, events, or places, it is entirely fictional and for entertainment purposes only.
        </div>
      </div>
      <div class="w-full mt-6 text-center">
        <ChatMessage v-for="message in messages" :message="message" />
      </div>
      <div v-if="error"  class="w-full mt-6 text-center">
        <div class="p-4 mb-4 text-left text-sm text-red-800 rounded-lg bg-red-50 dark:bg-gray-800 dark:text-red-400" role="alert">
          <span class="font-medium">Error:</span> {{ error }}
        </div>
      </div>
      <div v-if="pending" class="w-full mt-6 text-center">
        <span class="text-3xl">...</span>
      </div>
      <form @submit.prevent="" class="mt-4">
        <label for="search" class="mb-2 text-sm font-medium text-gray-900 sr-only dark:text-white">Prompt</label>
        <div class="relative">
          <input type="text" v-model="text" id="search" :disabled="isPromptDisabled()"
                 class="block w-full p-4 ps-10 text-md text-gray-900 border border-gray-300 rounded-lg bg-gray-50 disabled:bg-gray-200 disabled:ring-gray-500 disabled:cursor-not-allowed 0 focus:ring-blue-500 focus:border-blue-500
                    dark:bg-gray-700 dark:border-gray-600 dark:placeholder-gray-400 dark:text-white dark:focus:ring-blue-500 dark:focus:border-blue-500"
                 placeholder="Enter your prompt here..." required />
          <button type="submit" @click="send" :disabled="isSendDisabled()"
                  class="text-white absolute end-2.5 bottom-2.5 bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed hover:bg-blue-800 focus:ring-4 focus:outline-none
                    focus:ring-blue-300 font-medium rounded-lg text-sm px-4 py-2 dark:bg-blue-600 dark:hover:bg-blue-700 dark:focus:ring-blue-800">
            Send
          </button>
        </div>
      </form>
    </div>
  </div>
</template>

<script setup lang="js">

import Persona from "./Persona.vue";
import {ref} from "vue";
import ChatMessage from "./ChatMessage.vue";

const loremIpsum = {
  name: "Lorem Ipsum",
  description: " Lorem Ipsum is a mysterious and enigmatic figure known for their profound wisdom and cryptic " +
      "communication style. Often seen as a wandering sage, they leave behind fragments of ancient texts that spark " +
      "curiosity and inspire creativity. With an aura of timeless knowledge, Lorem Ipsum bridges the gap between the " +
      "past and the future, offering insights that transcend the boundaries of conventional understanding.",
  image: "https://i.pravatar.cc/256?img=22",
  fallback: true
}

let socket = null

const connected = ref(false)
const pending = ref(false)
const error = ref(null)
const messages = ref([])
const persona = ref(null)
const text = ref("")

fetchPersona()
fetchPrompt()
connect()

function fetchPersona() {
  persona.value = null
  fetchRandomPersona((p) => persona.value = p, loremIpsum)
}

function fetchPrompt() {
  text.value = null
  const fallbackPrompts = ['Who am I talking to?', 'Tell me something about yourself']
  const randomIndex = Math.floor(Math.random() * fallbackPrompts.length)
  const fallbackPrompt = fallbackPrompts[randomIndex]
  fetchRandomPrompt((resp) => text.value = resp.prompt, { prompt: fallbackPrompt })
}

async function fetchRandomPersona(setter, fallback) {
  try {
    const response = await fetch('http://localhost:9091/persona/random')
    const json = await response.json()
    setter(json)
  } catch (error) {
    setter(fallback)
  }
}

async function fetchRandomPrompt(setter, fallback) {
  try {
    const response = await fetch('http://localhost:9092/prompt/random');
    const json = await response.json()
    setter(json)
  } catch (error) {
    setter(fallback)
  }
}

function isPromptDisabled() {
  return connected.value !== true || persona.value === null
}

function isSendDisabled() {
  return connected.value !== true || persona.value === null || text.value === ''
}

function send() {
  if (!connected) {
    return
  }

  const message = {
    text: text.value,
    type: 'chat'
  }
  messages.value.push(message)

  const sendMessage = {
    ... message,
    persona: persona.value
  }
  pending.value = true
  socket.send(JSON.stringify(sendMessage))
}

function connect() {
  disconnect()

  const protocol = location.protocol === 'https:' ? 'wss' : 'ws'
  socket = new WebSocket(`${protocol}://${location.host}/ws/chat`)

  socket.onmessage = (message) => {
    const json = JSON.parse(message.data)
    console.log('Message received', json)

    pending.value = false
    text.value = ""
    if (json.type === 'chat') {
      messages.value.push(json)
    } else if (json.type === 'failure') {
      error.value = json.error
      disconnect()
    }
  }

  socket.onopen = () => {
    console.log('Connected to server')
    connected.value = true
  }

  socket.onclose = () => {
    console.log('Disconnected from server')
    connected.value = false
  }

  socket.onerror = (error) => {
    console.log('Websocket error', error)
    pending.value = false
    error.value = error
  }
}

function disconnect() {
  socket?.close()
  socket = null
  console.log("Socket closed")
}

</script>